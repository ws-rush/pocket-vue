import{_ as t,c as a,o as i,af as o}from"./chunks/framework.W5ZyBR1w.js";const u=JSON.parse('{"title":"Comparison with Standard Vue","description":"","frontmatter":{},"headers":[],"relativePath":"guide/vs-vue.md","filePath":"guide/vs-vue.md"}'),n={name:"guide/vs-vue.md"};function r(s,e,l,d,c,h){return i(),a("div",null,[...e[0]||(e[0]=[o('<h1 id="comparison-with-standard-vue" tabindex="-1">Comparison with Standard Vue <a class="header-anchor" href="#comparison-with-standard-vue" aria-label="Permalink to “Comparison with Standard Vue”">​</a></h1><p>While <code>pocket-vue</code> shares the same template syntax and reactivity system as standard Vue, its purpose and implementation are fundamentally different. Understanding these differences is key to knowing when to use it.</p><h2 id="the-goal-progressive-enhancement" tabindex="-1">The Goal: Progressive Enhancement <a class="header-anchor" href="#the-goal-progressive-enhancement" aria-label="Permalink to “The Goal: Progressive Enhancement”">​</a></h2><p><code>pocket-vue</code> is not intended to be a smaller replacement for Vue. It is specifically designed for <strong>progressive enhancement</strong>. This means it&#39;s optimized for &quot;sprinkling&quot; a small amount of interactivity onto existing HTML pages that are primarily rendered by a server framework (like Rails, Django, or Laravel).</p><h2 id="implementation-differences" tabindex="-1">Implementation Differences <a class="header-anchor" href="#implementation-differences" aria-label="Permalink to “Implementation Differences”">​</a></h2><p>The key difference lies in how templates are handled.</p><h3 id="standard-vue-without-a-build-step" tabindex="-1">Standard Vue (without a build step) <a class="header-anchor" href="#standard-vue-without-a-build-step" aria-label="Permalink to “Standard Vue (without a build step)”">​</a></h3><p>When you use standard Vue by mounting it to in-DOM templates, the process is less than optimal for simple enhancements:</p><ol><li><strong>Compiler Overhead</strong>: You must ship the full Vue template compiler to the browser, which adds around 13kb to your bundle size.</li><li><strong>DOM to String</strong>: The compiler has to retrieve the template as a string from the already-instantiated DOM.</li><li><strong>Compilation</strong>: The string is then compiled into a JavaScript render function.</li><li><strong>Virtual DOM &amp; Replacement</strong>: Vue creates a virtual DOM from the render function and then replaces the existing DOM template with new DOM nodes.</li></ol><p>This process is powerful and necessary for building complex Single-Page Applications (SPAs), but it&#39;s overkill for adding simple interactions.</p><h3 id="pocket-vue" tabindex="-1"><code>pocket-vue</code> <a class="header-anchor" href="#pocket-vue" aria-label="Permalink to “pocket-vue”">​</a></h3><p><code>pocket-vue</code> avoids this overhead by taking a more direct approach, similar to Vue 1:</p><ol><li><strong>No Compiler</strong>: There&#39;s no template compiler shipped to the browser.</li><li><strong>Direct DOM Manipulation</strong>: It walks the existing DOM and attaches fine-grained reactive effects directly to the elements. The DOM itself is the template.</li></ol><p>This makes <code>pocket-vue</code> much more efficient and lightweight for its intended use case.</p><h2 id="trade-offs" tabindex="-1">Trade-offs <a class="header-anchor" href="#trade-offs" aria-label="Permalink to “Trade-offs”">​</a></h2><p>This direct-to-DOM approach comes with trade-offs:</p><ul><li><strong>Platform Agnostic Rendering</strong>: Because it&#39;s tightly coupled to the DOM, <code>pocket-vue</code> cannot be used for platform-agnostic rendering (e.g., native mobile).</li><li><strong>No Render Functions</strong>: You lose the ability to work with render functions for advanced abstractions.</li><li><strong>No SSR</strong>: JavaScript SSR is not possible.</li></ul><p>However, these capabilities are rarely needed in the context of progressive enhancement, making <code>pocket-vue</code> the optimal tool for the job. If you find yourself needing these features, you should probably be using standard Vue with a build setup.</p>',18)])])}const m=t(n,[["render",r]]);export{u as __pageData,m as default};
